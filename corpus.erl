%% This file is used for generating the documentation. It contains
%% erlang code with corresponding descriptions.

-h1("Erlang Abstract Format").

-p("The Erlang Abstract Format is used in parse trees in various tools, such "
   "as the compiler and preprocessor modules shipped with Erlang/OTP. A brief "
   "documentation is available at http://erlang.org/doc/apps/erts/absform.html. "
   "However, the complete syntax of abstract format is not documented.").

-p("This is an attempt to document every langugage construct by examples. "
   "The examples are generated using Erlang source code, "
   "which is parsed to generate the abstract form, and pretty-printed again to "
   "generate the Erlang code examples.").

-p("For a complete insight, see the files corpus.erl and generate_docs.escript").

-p("Every form is a tuple. The second element is the line number in the source "
   "file.").

-h2("Types").

-p("Types, mostly in the order as listed under \"Types and their Syntax\""
         " on http://erlang.org/doc/reference_manual/typespec.html.").

-p("Abstract form syntax for types: `{type, Line, TypeName, TypeParams}`.").

-type t() :: any().
-type t() :: none().
-type t() :: pid().
-type t() :: port().
-type t() :: reference().
-type t() :: [].
-type t() :: atom().

%% Binary
-type t() :: <<>>.
-type t() :: <<_:M>>.                   %% M is a positive integer
-type t() :: <<_:_*N>>.                 %% N is a positive integer
-type t() :: <<_:M, _:_*N>>.

-type t() :: float().

%% Function
-type t() :: fun().                         %% any function
-type t() :: fun((...) -> integer()).       %% any arity, returning Type
-type t() :: fun(() -> integer()).
-type t() :: fun((atom(), atom()) -> integer()).

%% Integer
-type t() :: integer().
-type t() :: 42.                            %% specifies an integer range
-type t() :: 1..10.                         %% ..., -1, 0, 1, ... 42 ...

%% List
-type t() :: list(integer()).                           %% Proper list ([]-terminated)
-type t() :: maybe_improper_list(integer(), atom()).    %% Type1=contents, Type2=termination
-type t() :: nonempty_improper_list(integer(), atom()). %% Type1 and Type2 as above
-type t() :: nonempty_list(integer()).                  %% Proper non-empty list

%% Map
-type t() :: map().                         %% denotes a map of any size
-type t() :: #{}.                           %% denotes the empty map
-type t() :: #{%atom() := integer(),         %% denotes a mandatory association
               integer() => any()}.         %% denotes an optional association

%% Tuple
-type t() :: tuple().                       %% denotes a tuple of any size
-type t() :: {}.
-type t() :: {atom()}.
-type t() :: {atom(), integer()}.

%% Union
-type t() :: atom() | integer().

%% ----------------

-p("For convenience, the following types are also built-in. They can be "
   "thought as predefined aliases for the type unions shown in the code "
   "comments.").

%% The following lines are generated by piping the table "Built in, Defined
%% as" on the page http://erlang.org/doc/reference_manual/typespec.html
%% copy-pasted using Firefox to the following perl one-liner:
%%
%% perl -pe 's/^(\S+) *\t([^\n\t]+)$/-comment("$1 :: $2").\n-type t() :: $1./'
-comment("term() :: any()").
-type t() :: term().
-comment("binary() :: <<_:_*8>>").
-type t() :: binary().
-comment("bitstring() :: <<_:_*1>>").
-type t() :: bitstring().
-comment("boolean() :: 'false' | 'true'").
-type t() :: boolean().
-comment("byte() :: 0..255").
-type t() :: byte().
-comment("char() :: 0..16#10ffff").
-type t() :: char().
-comment("nil() :: []").
-type t() :: nil().
-comment("number() :: integer() | float()").
-type t() :: number().
-comment("list() :: [any()]").
-type t() :: list().
-comment("maybe_improper_list() :: maybe_improper_list(any(), any())").
-type t() :: maybe_improper_list().
-comment("nonempty_list() :: nonempty_list(any())").
-type t() :: nonempty_list().
-comment("string() :: [char()]").
-type t() :: string().
-comment("nonempty_string() :: [char(),...]").
-type t() :: nonempty_string().
-comment("iodata() :: iolist() | binary()").
-type t() :: iodata().
-comment("iolist() :: maybe_improper_list(byte() | binary() | iolist(), binary() | [])").
-type t() :: iolist().
-comment("function() :: fun()").
-type t() :: function().
-comment("module() :: atom()").
-type t() :: module().
-comment("mfa() :: {module(),atom(),arity()}").
-type t() :: mfa().
-comment("arity() :: 0..255").
-type t() :: arity().
-comment("identifier() :: pid() | port() | reference()").
-type t() :: identifier().
-comment("node() :: atom()").
-type t() :: node().
-comment("timeout() :: 'infinity' | non_neg_integer()").
-type t() :: timeout().
-comment("no_return() :: none()").
-type t() :: no_return().
%%---

-p("Built-in types; can be thought defined by the syntax...").
%% perl -pe 's/^(\S+) *\t([^\n\t]+)$/-comment("$1 :: $2").\n-type t() :: $1./'
-comment("non_neg_integer() :: 0..").
-type t() :: non_neg_integer().
-comment("pos_integer() :: 1..").
-type t() :: pos_integer().
-comment("neg_integer() :: ..-1").
-type t() :: neg_integer().

-h2("Record declarations").

-p("A record is represented as a form without types. If any fields are typed, "
   "the form is followed by a 'record type' form. Thus, for records with typed "
   "fields, there are two consecutive forms.").

-record(myrec, {field1 = foo :: atom(),
                field2       :: undefined,
                field3 = foo,
                field4}).
